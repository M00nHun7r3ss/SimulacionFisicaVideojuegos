1. Nace particula en generador particulas (x numero de particulas)
2. Atributos random - posicion inicial (de la particula y del sistema), velocidad,
tiempo vida, (aceleracion*), (dumping*), color, tamaño, forma. 
Con distribuciones de probabilidad (DISTRIBUCION NORMAL)
3. Se extinguen las particulas a las que se les ha acabado el tiempo de vida, o...
(condiciones extra como la posición, al salir de pantalla, nº max particulas, 
cambio color)
4. Se les aplican a las partículas unas fuerzas, y se updatea lo que toque hacer.
5. Render


cascada o fuente. generacion de particulas constantes.
humo

Para degradado metodo de rgb a hsv

Particulas en vector/lista



//Clase ParticlesSystem -
Lista de partículas* (o un enum)
Lista de generadores de particulas* - devuelve lista de partículas y las metemos a la lista de partículas de la situacion
Update(tiempo) {
3. Se extinguen las particulas a las que se les ha acabado el tiempo de vida, o...
(condiciones extra como la posición, al salir de pantalla, nº max particulas, 
cambio color) y las borra de la lista
4. Se les aplican a las partículas unas fuerzas (integrate()), y se updatea lo que toque hacer.}
1. Nace particula en generador particulas (x numero de particulas)
}


clase abstracta generador particulas {

DISTRIBUCION UNIFORME - lluvia
std::uniform_real_distribution<double> 
P + R * var - uniforme{0,1}


desviacionPos
desvVel
DesvTVida
x = x * media + distribucion(random) * desvP.x



DISTRIBUCION NORMAL / GAUSS - fuego, niebla...
std::normal_real_distribution<double> - d{0,1}

virtual generarParticulas() = 0;
{
nº de partículas
probabilidad de generación (o random números de particulas)
p = partícula modelo

}


setOrigin()
getOrigin()
setVelMedia()
getVelMedia()
setDurationMedia()
getDurationMedia()
setProbGeneration() //nº de particulas generadas en cada update()
getProbGeneration()
Nº particulas
}

se crea la partícula base y se otorgan luego los atributos con mis setters super chulos


Para generar random en particulas Mersenne 
std::mt19937 (de 0 a 1 y lo escalo con la variacion)


En el integrate() de las partículas ir disminuyendo el tiempo de vida.






////////////////////////////////////////////////
-------------- PRACTICA FUERZAS ----------------
////////////////////////////////////////////////

Particle.h: 
Añadir masa (o su inverso)
No tener aceleración inicial
Método AddForce() - se actualiza al principio de cada ciclo 
Método ClearForce() - al final de cada ciclo, se limpian las fuerzas que hay

Clase Abstracta ForceGenerator
Para crear las diferentes fuerzas

Cada partícula tiene una fuerza diferente. ForceParticleRegister - lista de fuerza-partícula para un registro.
Saber qué fuerzas tiene cada partícula y que partículas se ven aportadas por cada fuerza
Update() - se actualizan las fuerzas de cada partícula y se le envia al AddForce()


FUERZAS
	- Gravedad
	- Viento
	- Torbellino
	- Explosión


El sistema de partículas tiene una referencia a las fuerzas que se le aplican a esas partículas.



////////////////////////////////////////////////
-------------- PRACTICA MUELLES ----------------
////////////////////////////////////////////////

2 generadores de fuerza
Usar Hooke
Muelle unido a x: if x == pared, es una part que se mueve y otra que no. 

   A /\/\/\/\/\/\ B

a sufre una fuerza segun lo que esta estirado el muelle
b sufre una fuerza segun la distancia de b-a

Include forcegenerator

Construct(k, distancia reposo, particula* 2)

-x * k 
update force - vector que une b y a (ya esta negado)
crea fuerza

defino distancia y normalizo (modulo)
delta es distancia - longitud reposo

fuerza = distancia * delta * k

y devolvemos la fuerza

Para dos particulas creamos 2 generadores de fuerza de este muelle

PARA A Y OBJETO ESTATICO

Construct(k, distancia reposo, vEC 3 POS)
Para esto creamos un solo generador de fuerza de este muelle


Añadir dumping (el de integrar)


Muelle camara??? - afecta a camara, pero al muelle no. 
Es la cam la que tiene el generador



////////////////////////////////////////////////
------------ PRACTICA FLOTABILIDAD -------------
////////////////////////////////////////////////
ARQUIMEDAS: volumen desplazado = volumen sumergido
	    VOLUMEN * DENSIDAD 


Construct (altura, volumen, densidad)

updateForce(particula)

altura, volumen, densidad liquido, gravedad

h - getPos.y
h0 - altura del objeto en agua

ver la cantidad de inmesion
inmersion =

h - h0 > 0.5 * altura ----- inmers = 0
h0 - h >  0.5 * altura ---- inmers = 1
else inmersion = h0- h / altura + 0.5

fuerza.y = densidad * volumen * inmersion * gravedad













